# Desktop Focus Helper – Project Plan

## 1. Purpose & Immediate Value
The Desktop Focus Helper runs locally on the user's machine, monitors keyboard activity, mouse movement, active window titles, and (for browsers) open tab URLs. When the tool detects a drop in activity or a switch to a known “distracting” app/tab, it plays a short audio cue (“You’re drifting!” or an encouraging phrase). The user gets instant, audible feedback that nudges them back to work without needing any manual status tracking.

## 2. Key Technologies & Justifications
- **Python 3.11** – batteries‑included, excellent cross‑platform libraries, runs inside the headless Docker container.
- **typer** – simple CLI framework; zero‑config entry point.
- **pynput** – lightweight cross‑platform keyboard/mouse listener (pure Python, no external binaries).
- **psutil** – fetch current active process/window titles on Windows/macOS/Linux.
- **webbrowser + selenium‑wire (optional stub)** – we’ll stub browser‑tab detection; real implementation can be swapped later.
- **playsound** – plays short WAV/MP3 files; works without complex audio back‑ends.

**Verification** – A short script `focus_helper.py` will run, print detected activity stats, and play a test audio file on demand.

## 3. Minimum Viable Interactions
1. **Start monitoring** – `python focus_helper.py start`. CLI streams live stats to stdout (keystrokes per minute, mouse moves per minute, active window name).
2. **Detect distraction** – If activity falls below a configurable threshold for 30 s, the app plays `alert.wav` (“Focus!”).
3. **Encourage** – If activity rises above a threshold after a dip, play `cheer.wav` (“Great job!”).
4. **Stop monitoring** – `python focus_helper.py stop`.

**Verification** – Run `python focus_helper.py demo` which simulates low activity and triggers both audio cues automatically.

## 4. File Structure & Startup
```
project/
├─ focus_helper.py      # entry point, Typer CLI
├─ monitor.py           # core activity collector
├─ audio.py             # thin wrapper around playsound
├─ config.yaml          # default thresholds, audio file paths
├─ assets/
│   ├─ alert.wav
│   └─ cheer.wav
├─ requirements.txt
└─ project_plan.txt
```
**Verification** – `tree` shows the layout; running `python focus_helper.py --help` displays help without error.

## 5. Core Logic Plan
- **monitor.py**
  - `class ActivityMonitor:`  
    - `__init__(self, cfg: dict)` – loads thresholds.  
    - `start(self) -> None` – spawns `pynput` listeners and a background thread that polls `psutil` for active window names every second.  
    - `stop(self) -> None` – cleanly shuts down listeners.  
    - `get_stats() -> dict` – returns `{keystrokes_per_min, mouse_moves_per_min, active_window}`.
- **audio.py**
  - `def play_sound(path: str) -> None` – thin wrapper around `playsound.playsound`.
  - `def alert() -> None` – plays alert.wav.  
  - `def cheer() -> None` – plays cheer.wav.
- **focus_helper.py**
  - Typer commands:
    - `start` – creates `ActivityMonitor`, starts it, and enters a loop that checks `get_stats()` every 5 s; decides when to call `audio.alert()` or `audio.cheer()`.
    - `demo` – runs a short simulation that forces low activity (by ignoring listener callbacks) to showcase audio feedback.
    - `stop` – signals the monitor to stop (mainly for completeness; not needed in demo).
  - Helper: `load_config()` reads `config.yaml`.

**Verification** – Import modules in a Python REPL and call `ActivityMonitor().get_stats()`; call `audio.alert()` manually to hear sound.

## 6. Build & Run Instructions
1. **Install dependencies**  
   ```bash
   pip install -r requirements.txt
   ```
2. **Run demo**  
   ```bash
   python focus_helper.py demo
   ```
   You should hear “alert” then “cheer” sounds with printed stats.
3. **Start real monitoring**  
   ```bash
   python focus_helper.py start
   ```
   Press `Ctrl‑C` to stop.

**Verification** – Following the steps inside the container should produce console output and audio (container may need host audio forwarding; for verification we’ll use a printed placeholder if audio cannot play).

## 7. Stubbing & Shortcuts
- **Browser tab detection** – Not implemented now; `monitor.py` only reports the active window title. A placeholder function `get_browser_tabs()` returns an empty list and is documented for future Selenium integration.
- **Audio** – If the host cannot play sound, `audio.play_sound` falls back to printing “[AUDIO: <file>]”.
- **OS‑specific window title** – `psutil` provides generic `process.name()`; on Windows we’ll use `win32gui` if available, otherwise fallback to process name. The code checks availability and degrades gracefully.

**Verification** – Running the demo on any OS prints “[AUDIO: ...]” if actual playback fails, confirming the stub works.

## 8. Completion Checklist
- [x] `requirements.txt` lists exact versions (`typer==0.12.3`, `pynput==1.7.6`, `psutil==5.9.8`, `playsound==1.3.0`).
- [x] `focus_helper.py --help` displays commands.
- [x] `python focus_helper.py demo` runs without error, prints stats, and triggers both audio stubs.
- [x] Real monitoring (`start`) prints live activity every 5 s.
- [x] Audio fallback prints placeholder when sound can’t be played.
- [x] Project tree matches the structure above.
- [x] All code is in a single repository; no external services required.

---
*This plan delivers a usable “focus helper” that can be tried instantly, with clear extension points for richer window/tab detection and polished audio.*  
